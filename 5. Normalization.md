# Database Normalization

## What is Normalization?
Normalization is a systematic process in database design used to organize data in a relational database to reduce redundancy and improve data integrity. It involves dividing large tables into smaller, related tables and defining relationships between them using primary and foreign keys. The goal is to eliminate data anomalies (issues like insertion, update, or deletion problems) that can occur in unnormalized databases.

Normalization is guided by a set of rules called Normal Forms (NF), each building on the previous one. A database is said to be in a particular normal form if it satisfies the criteria for that form and all lower forms.

## Why Normalization?
Normalization is essential for several reasons:
- **Reduces Data Redundancy:** By breaking down data into smaller tables, duplicate data is minimized, saving storage space and ensuring consistency.
- **Improves Data Integrity:** Ensures that data dependencies are logical and that updates don't lead to inconsistencies.
- **Prevents Anomalies:**
  - **Insertion Anomaly:** Difficulty adding new data without adding unrelated data (e.g., can't add a student without a course if they're in the same table).
  - **Update Anomaly:** Changing data in one place requires updates in multiple places, risking inconsistency.
  - **Deletion Anomaly:** Removing data deletes unrelated information (e.g., deleting a student removes course details if shared).
- **Enhances Query Performance:** Well-normalized schemas can lead to more efficient joins and queries in the long run, though denormalization might be used for read-heavy systems.
- **Facilitates Maintenance:** Easier to modify schema without affecting large portions of data.

Without normalization, databases become prone to errors, inefficiency, and scalability issues.

## Avoiding Redundancy
Redundancy occurs when the same data is stored in multiple places, leading to wasted space and potential inconsistencies (e.g., if a customer's address changes, it must be updated everywhere). Normalization avoids this by:
- Storing each piece of data in only one place.
- Using relationships (foreign keys) to link tables.
- Ensuring functional dependencies are properly managed (e.g., non-key attributes depend only on the primary key).

For example, in an unnormalized table with employee and department details repeated for each employee, normalization splits it into separate Employee and Department tables, linking via DepartmentID.

## Types of Normal Forms (1NF, 2NF, 3NF, 4NF)
Normalization progresses through levels, each addressing specific issues. Here are the main ones up to 4NF (higher forms like BCNF, 5NF exist but are less common).

### 1NF (First Normal Form)
- **Definition:** A table is in 1NF if:
  - All attributes contain atomic (indivisible) valuesâ€”no multivalued attributes or repeating groups.
  - Each row is unique (primary key defined).
- **Example:**
  - Unnormalized: Student table with Courses as a list (e.g., Row: ID=1, Name=Alice, Courses=Math,Science).
  - 1NF: Split into separate rows or a new table: ID=1, Name=Alice, Course=Math; ID=1, Name=Alice, Course=Science.
- **Purpose:** Eliminates repeating groups for easier querying.

### 2NF (Second Normal Form)
- **Definition:** Table must be in 1NF, and all non-key attributes must be fully functionally dependent on the entire primary key (no partial dependencies).
- **Example:**
  - Table: OrderID (PK), ProductID (PK), ProductName, Quantity.
  - Issue: ProductName depends only on ProductID (partial dependency).
  - 2NF: Split into Orders (OrderID, ProductID, Quantity) and Products (ProductID, ProductName).
- **Purpose:** Removes partial dependencies to avoid update anomalies.

### 3NF (Third Normal Form)
- **Definition:** Table must be in 2NF, and no non-key attribute depends on another non-key attribute (no transitive dependencies).
- **Example:**
  - Table: EmployeeID (PK), Name, Department, DeptLocation.
  - Issue: DeptLocation depends on Department (transitive).
  - 3NF: Split into Employees (EmployeeID, Name, Department) and Departments (Department, DeptLocation).
- **Purpose:** Eliminates transitive dependencies for better integrity.

### 4NF (Fourth Normal Form)
- **Definition:** Table must be in 3NF (or BCNF), and no multivalued dependencies (independent multivalued facts about an entity).
- **Example:**
  - Table: EmployeeID (PK), Skill, Language.
  - Issue: Skills and Languages are independent multivalued attributes.
  - 4NF: Split into EmployeeSkills (EmployeeID, Skill) and EmployeeLanguages (EmployeeID, Language).
- **Purpose:** Handles multivalued dependencies to prevent redundancy in complex relationships.

**Summary Table of Normal Forms:**

| Normal Form | Prerequisite | Key Rule | Addresses |
|-------------|--------------|----------|-----------|
| **1NF**    | None        | Atomic values, no repeating groups | Repeating groups |
| **2NF**    | 1NF         | Full functional dependency on PK | Partial dependencies |
| **3NF**    | 2NF         | No transitive dependencies | Transitive dependencies |
| **4NF**    | 3NF         | No multivalued dependencies | Multivalued dependencies |

## Advantages of Normalization
- **Minimized Redundancy:** Less duplicate data, reducing storage and inconsistency risks.
- **Data Consistency and Integrity:** Enforces rules that prevent anomalies and ensure accurate data.
- **Easier Maintenance:** Smaller tables make updates, additions, and schema changes simpler.
- **Better Security:** Can apply access controls at table level.
- **Scalability:** Normalized designs handle growth better without massive rework.
- **Efficient Storage:** Though more tables, overall space is optimized by avoiding duplicates.

**Note:** Over-normalization can lead to too many joins, slowing queries. Denormalization (intentional redundancy) is sometimes used for performance in read-heavy systems like data warehouses.
